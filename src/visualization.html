<html>


<head>
    <title>ISBN Maps</title>
    <script src="https://unpkg.com/deck.gl@9.0.38/dist.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

</head>

<body>

    <div class="deck-wrapper" id="deck1">
        <select id="select1" class="dataset-select"></select>
        <div id="deckGLContainer1" class="deckGLContainer"></div>
    </div>

    <div class="deck-wrapper" id="deck2">
        <select id="select2" class="dataset-select"></select>
        <div id="deckGLContainer2" class="deckGLContainer"></div>
    </div>


</body>

<script type="text/javascript">
    // const ROOT_URL = window.location.origin + window.location.pathname + "/tiles";
    const ROOT_URL = "tiles";
    const DATASETS = [
        "md5_files",
        "libby_files",
        "ol_files"
    ];

    const TILE_SIZE = 400;
    const WIDTH = 200000;
    const HEIGHT = 400;
    const MAX_LEVEL = Math.max(1, Math.ceil(Math.log2(WIDTH))); // estimate the max level

    // make an eventlistener to find out whether the mouse is currently above #deckGLContainer1 or #deckGLContainer2 (or none):
    let hoveringElement = null;
    document.getElementById("deck1").addEventListener("mouseover", function () {
        hoveringElement = "deck1"
    });
    document.getElementById("deck2").addEventListener("mouseover", function () {
        hoveringElement = "deck2"
    });


    function populateDropdowns() {
        document.querySelectorAll('.dataset-select').forEach(select => {
            DATASETS.forEach(dataset => {
                let option = document.createElement("option");
                option.value = dataset;
                option.textContent = dataset;
                select.appendChild(option);
            });
        });
    }

    async function initializeDeck() {
        const dimensions = {
            width: WIDTH,
            height: HEIGHT,
            maxLevel: MAX_LEVEL,
        };

        const renderBitmapLayer = (props) => {
            const [[left, bottom], [right, top]] = props.tile.boundingBox;
            const { width, height } = dimensions;
            return new deck.BitmapLayer(props, {
                data: undefined,
                image: props.data,
                bounds: [
                    Math.max(left, 0),
                    Math.min(top, height),
                    Math.min(right, width),
                    Math.max(bottom, 0),
                ],
            });
        };

        const createTileLayer = (tileSet) => {
            return new deck.TileLayer({
                id: tileSet,
                pickable: true,
                tileSize: TILE_SIZE,
                minZoom: -7,
                maxZoom: 0,
                extent: [0, 0, dimensions.width, dimensions.height],
                data: null,
                getTileData: ({ index }) => {
                    const { x, y, z } = index;
                    const path = `${ROOT_URL}/${tileSet}/${dimensions.maxLevel + z}/${x}_${y}.png`;
                    return loaders.load(path)
                },
                renderSubLayers: renderBitmapLayer,
            });
        };
        const tileLayer1 = createTileLayer(DATASETS[0]);
        const tileLayer2 = createTileLayer(DATASETS[1]);
        const deck1 = new deck.DeckGL({
            container: document.getElementById("deckGLContainer1"),
            views: new deck.OrthographicView({ id: "ortho" }),
            initialViewState: {
                target: [dimensions.width / 2, dimensions.height / 2, 0],
                zoom: -5,
            },
            controller: true,
            layers: [tileLayer1],
            onViewStateChange: ({ viewState }) => {
                // only if mouse is currently hovering over this decks container #deckGLContainer1 (and NOT the other deck)
                if (hoveringElement === "deck1") {
                    syncZoomAndPan(viewState, deck2);
                }
            }
        });

        const deck2 = new deck.DeckGL({
            container: document.getElementById("deckGLContainer2"),
            views: new deck.OrthographicView({ id: "ortho" }),
            initialViewState: {
                target: [dimensions.width / 2, dimensions.height / 2, 0],
                zoom: -5,
            },
            controller: true,
            layers: [tileLayer2],
            onViewStateChange: ({ viewState }) => {
                // only if mouse is currently hovering over this decks container #deckGLContainer2 (and NOT the other deck)
                if (hoveringElement === "deck2") {
                    syncZoomAndPan(viewState, deck1);
                }
            }
        });

        // function to adapt zoom and pan of the other deck when one is being moved
        function syncZoomAndPan(viewState, deckToChange) {
            deckToChange.setProps({
                viewState: viewState
            });
        }
    }

    populateDropdowns();
    initializeDeck();

</script>
<style>
    body {
        margin: 0;
        font-family: sans-serif;
        width: 100vw;
        height: 100dvh;
        overflow: hidden;
        background-color: #2c3e50;
    }

    .deckGLContainer {
        width: 90%;
        height: 100px;
        margin: 20px auto;
        border: 2px solid black;
    }
</style>

</html>